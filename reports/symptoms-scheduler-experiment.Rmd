---
title: "Symptoms - scheduler experiment"
author: "Carlos Granell, [SyMptOMS team](http://geotec.uji.es/projects/SyMptOMS/), [GEOTEC research group](http://geotec.uji.es/) "
date: "17/4/2020 (updated `r format(Sys.time(), '%d %B, %Y')`)"
output: 
  html_document:
    df_print: paged
    toc: yes
    toc_depth: 4
---

```{r setup, include=FALSE, eval=TRUE}
knitr::opts_chunk$set(echo = FALSE)
```

This document analyses the self-developed scheduler component in Android-based mobile devices as part of the [SyMptOMS project](http://geotec.uji.es/projects/SyMptOMS/). 


## Reproduce notebook

To create the PDF of the computational notebook you can run the following commands in a new R session.
If you have problems rendering the PDF you can execute each chunk independently in [RStudio](https://rstudio.com/products/rstudio/).

```{r render_with_rmarkdown, eval=FALSE}
require("knitr")
require("rmarkdown")
rmarkdown::render("symptoms-scheduler-experiment.Rmd", output_format = "pdf_document")
```

This document does not install the required R packages by default.
You can run the script `install.R` to install all required dependencies on a new R installation, or use `install.packages(..)` to install missing R packages.

```{r install_r, eval=FALSE}
source("R/install.R")
```

The plots and tables use the packages [`ggplot2`](http://ggplot2.tidyverse.org/), [`knitr::kable()`](https://yihui.name/knitr/) and [`kableExtra`](https://cran.r-project.org/package=kableExtra).

Required libraries and runtime environment description are as follows.

```{r load_libraries, echo=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
library(kableExtra)
library(here)
# library(googledrive)
library(lubridate)
library(stringr)
library(scales)
# library(plotly)
library(grid)
library(gridBase)
library(gridExtra)
library(egg)
```


```{r set_seed}
# just in case
set.seed(nchar("Symptoms - scheduler experiment"))
```

## Data download

Log files are stored in shared gdrvie folder. This notebook downloads them locally in the folder`data-raw`.

```{r gsheetdata_files}

files <- tibble(
  experiment = c(rep("#1", 5), rep("#2", 5)),
  gsheets_name = c("AD_BQ.csv", "AD_NV.csv", "AD_A1.csv", "BA_H9.csv", "BA_MO.csv",
                   "BA_BQ.csv", "BA_NV.csv", "BA_A1.csv", "AD_H9.csv", "AD_MO.csv"),
  gsheets_link = c("https://drive.google.com/open?id=1fP9r0S8ORa689yHRtfCtYQothLuGcCw3",
                   "https://drive.google.com/open?id=1l-vnaT-Smy0SegArIz5A108-IQ2_jmVV",
                   "https://drive.google.com/open?id=1gzk1ezN5t5yBv2RnbznUqvalDx97eu3o",
                   "https://drive.google.com/open?id=1BLXO4Rvz6ppWFJe5oN9Y0hKh__ypofxk",
                   "https://drive.google.com/open?id=1RizGjKR8QLOdJna7qGPP7dYX9WWAysO4",
                   "https://drive.google.com/open?id=1rfaooLZ0Up0gNx1SCA92TV1JFxcLU0sk",
                   "https://drive.google.com/open?id=1_KIXX5FGXv7MO37QbUDnd_KGqiGihiMI",
                   "https://drive.google.com/open?id=1LezrtyB9i4K7cQsmI78E0v_KaOyhZcXI",
                   "https://drive.google.com/open?id=1ISjsfSLZt6n9miryQtDr-tsZV9bfbCDT",
                   "https://drive.google.com/open?id=1bx2RVNz05qVKGr-32GI-ZIOKQWlqKBPz")
)
```

```{r gsheetdata_files_table}
kable(files,
      format = "html",
      booktabs = TRUE,
      caption = "Table. List of raw data files.") %>%
  kable_styling(full_width = TRUE, bootstrap_options = c("striped", "bordered", "condensed"))

```


```{r gsheetdata_download, eval=FALSE}
for (f in 1:nrow(files)) {
  gfile_name <-files$gsheets_name[f]
  gfile_id <- googledrive::as_id(files$gsheets_link[f])
  
  drive_download(file = gfile_id, 
                 path = here::here("data-raw", gfile_name), 
                 overwrite = TRUE, verbose = FALSE)
}

```

```{r drive_disconnect, eval=FALSE}
drive_deauth()
```


## Data preparation

Raw data files are cleaned and merged together into a single file stored in the folder `data`. New fields such as dates breakdown are computed too. 

```{r merge_datafiles_defs}

schedulers <- c("AD" = "Advanced", 
                "BA" = "Basic")

devices <- c("BQ" = "BQ Aquaris V",
             "NV" = "Nvidia Shield Tablet",
             "A1" = "Xiaomi Mi A1",
             "H9" = "Honor 9",
             "MO" = "Motorola Moto G")

baseline_delay <- 60
```


```{r merge_datafiles, eval=FALSE}

data_path <- here::here("data-raw")
file_names <- list.files(path  = data_path)
file_paths <- list.files(path = data_path, full.names = TRUE)

data_merged <- data.frame()

get_experiment_id <- function(filename) {
  fullname <- paste0(filename, ".csv")
  files %>%
    filter(gsheets_name == fullname) %>%
    select(experiment) %>%
    pull
}

for (f in 1:length(file_names)) {
  filename <- stringr::str_sub(file_names[f], 1, 5)
  exp_id <- get_experiment_id(filename)
  
  parts <- stringr::str_split(filename, "_", simplify = TRUE)
  
  scheduler_id = parts[1]
  scheduler_name <- schedulers[[scheduler_id]]
  device_id <- parts[2]
  device_name <- devices[[device_id]]
  device_desc <- paste0(scheduler_name, " - ", device_name)
  
  data_temp <- read_csv(file_paths[f], col_names = TRUE, 
                        cols(
                          battery = col_double(),
                          exec_timestamp = col_double(),
                          planning_timestamp = col_double(),
                          task = col_character()
                        ))


  data_temp <- 
    data_temp %>%
    mutate(exp_id = exp_id,
           scheduler = scheduler_name,
           device_id = device_id,
           device_name = device_name,
           device_desc = device_desc) 
  
  data_merged <- rbind(data_merged, data_temp)
}       


data_merged <- 
  data_merged %>%
  mutate(exec_date = as_datetime(exec_timestamp/1000, tz="Europe/Madrid"),
         plan_date = as_datetime(planning_timestamp/1000, tz="Europe/Madrid"),
         plan_minute = lubridate::minute(plan_date),
         plan_hour = lubridate::hour(plan_date),
         plan_day = lubridate::day(plan_date),
         plan_month = lubridate::month(plan_date),
         exec_minute = lubridate::minute(exec_date),
         exec_hour = lubridate::hour(exec_date),
         exec_day = lubridate::day(exec_date),
         exec_month = lubridate::month(exec_date),
         time_period = ifelse(between(plan_hour,0, 7), "nighttime", "daytime"))


# Delay time is in seconds
data_merged <-
  data_merged %>%
  group_by(device_id) %>%
  arrange(plan_date) %>%
  mutate(step = row_number(),
         delay = (as.duration(interval(plan_date, exec_date)) - baseline_delay) / dseconds(1))


# Outliers
# means <- 
#   data_merged %>%
#   group_by(device_id) %>%
#   summarise(mean = round(mean(delay), 3),
#             sd = round(sd(delay), 3),
#             lo = round(mean - 2*sd, 3),
#             hi = round(mean + 2*sd, 3))
# 
# data_complete <- 
#   left_join(data_merged, means, by="device_id") %>%
#   mutate(outlier = ifelse((delay < lo | delay > hi), "yes", "no")) %>%
#   arrange(device_id, plan_date)
  

data_path <- here::here("data", "data.csv")
write_csv(data_complete, data_path)
data_path <- here::here("data", "data.rds")
saveRDS(data_complete, data_path)

#TODO: shiny app is deprecated
# data_path <- here::here("webapp","data", "data.csv")
# write_csv(data_complete, data_path)
# data_path <- here::here("webapp","data", "data.rds")
# saveRDS(data_complete, data_path)

```

__Key Variables__:

- quantitative (interval)

  - `plan_date` (_datetime_): task planning time.
  - `exec_date` (_datetime_): task execution time.  
- quantitative (ratio)

  - `delay` (_numeric_): execution delay in seconds ((`exec_date` - `plan_date`) - `r baseline_delay`).
- categorital (ordinal)

  - `battery`(_numeric_): battery level
- categorical (nominal)

  - `device_id`/`device_name`: device identifier/name
  - `exp_id`: experiment identifier.
  - `scheduler`: scheduler type.
  

## Exploratory analysis


### Summary statistics

```{r load_assessdata, warning=FALSE}
assessment_file <- here::here("data", "data.rds")
data <- readRDS(assessment_file)

n_observations <- nrow(data) 

```


```{r stats_summary_table}

# https://towardsdatascience.com/understanding-boxplots-5e2df7bcbd51
# Understanding Boxplot. What is a outlier?
# Min., 1st Qu., Median, Mean, 3rd Qu., Max.

col_names <- c("scheduler", "device_name", "min", "quartile1", "median", "quartile3", "max", "mean", "bottom_whisker", "top_whisker")
summaries <- data.frame(matrix(ncol=length(col_names), nrow = 0))
colnames(summaries) <- col_names

for (s in 1:length(schedulers)) {
  for (d in 1:length(devices)) {
    
    data %>%
      filter(scheduler == schedulers[[s]]) %>%
      filter(device_name == devices[[d]]) %>%
      select(device_id, device_name, delay) -> one
    
    summary_row <- data.frame(matrix(ncol=length(col_names), nrow = 0))
    colnames(summary_row) <- col_names
    
    mean <- mean(one$delay)
    summary_boxplot <- boxplot(one$delay, plot = FALSE) 
    bottom_whisker <- summary_boxplot$stats[1,1]
    top_whisker <-  summary_boxplot$stats[5,1]
    
    summary_row[1,] <- c(schedulers[[s]], devices[[d]], fivenum(one$delay), mean, bottom_whisker, top_whisker)

    summaries <- rbind(summaries, summary_row)
  }
}

summaries <- 
  summaries %>%
  mutate_at(vars(c("scheduler", "device_name")), ~as.character(.)) %>% 
  mutate_at(vars(-c("scheduler", "device_name")), ~as.numeric(.)) %>%
  mutate_if(is.numeric, ~round(., 3))

# glimpse(summaries)

data %>%
  group_by(exp_id, scheduler, device_name) %>%
  summarise(n = n(),
            start_datetime = min(plan_date),
            end_datetime = max(plan_date)) %>%
  inner_join(summaries, by=c("scheduler", "device_name")) %>%
  arrange(exp_id, scheduler, device_name) -> stats_summaries

kable(stats_summaries %>%
        select(`# exp` = exp_id,
               `Type scheduler` = scheduler,
               `Device` = device_name,
               `# records` = n,
               `Start` = start_datetime,
               `End` = end_datetime,
               `Min` = min,
               `Bottom whisker`= bottom_whisker,
               `1st Qu.` = quartile1,
               `Median` = median,
               `Mean` = mean,
               `3rd Qu.` = quartile3,
               `Top whisker`= top_whisker,
               `Max` = max),
      format = "html",
      booktabs = TRUE,
      caption = "Table. Descriptive statistics of data distribution and centrality per scheduler/device.") %>%
  kable_styling(full_width = TRUE, bootstrap_options = c("striped", "bordered", "condensed")) %>%
  collapse_rows(columns = 1:2, valign = "top") %>%
  # row_spec(6, color = "white", background = "orange") %>%
  row_spec(9:10, color = "white", background = "#D7261E")

```



```{r outliers}

# devices_OK <- c("BQ" = "BQ Aquaris V",
#                 "H9" = "Honor 9",
#                 "MO" = "Motorola Moto G")

data %>% 
  left_join(summaries, by=c("scheduler", "device_name")) %>%
  mutate(outlier_pos = ifelse(delay > top_whisker, 1, 0)) %>%
  mutate(outlier_neg = ifelse(delay < bottom_whisker, 1, 0)) %>%
  mutate(outlier = ifelse((outlier_pos == 1 | outlier_neg == 1), 1, 0)) %>%
  mutate(whisker = ifelse((delay > bottom_whisker & delay < quartile1) | (delay > quartile3 & delay < top_whisker), 1, 0)) %>%
  select(-min,-bottom_whisker, -quartile1, -mean, -median, -quartile3, -top_whisker, -max) %>%
  arrange(device_id, plan_date) -> data


n_outliers <- nrow(filter(data, outlier == 1))
n_whisker <- nrow(filter(data, whisker == 1))
n_irq <- nrow(filter(data, outlier == 0 & whisker == 0))

```

**Observations**:

- `r scales::comma(n_observations, big.mark = ".")` records in total. 

- `r round((n_irq / n_observations)*100, 1)`% (`r scales::comma(n_irq, big.mark = ".")`/`r scales::comma(n_observations, big.mark = ".")`) is the interquartile range or [IQR](https://en.wikipedia.org/wiki/Interquartile_range), i.e. the middle 50% of the data.

- `r round((n_whisker / n_observations)*100, 1)`% (`r scales::comma(n_whisker, big.mark = ".")`/`r scales::comma(n_observations, big.mark = ".")`) represent the _reasonable_ extremes of the data, i.e. these whisker values are the minimum and maximum values that do not exceed 1.5 × IQR.

- `r round((n_outliers / n_observations)*100, 1)`% (`r scales::comma(n_outliers, big.mark = ".")`/`r scales::comma(n_observations, big.mark = ".")`) are outliers, i.e. values beyond the top and bottom whiskers.

- `Nvidia Shield Tablet` has stopped triggering alarms on  **2020-04-17 22:27:06** when running the basic scheduler. Since there's no _watchdog_ in the basic version, this device is not going to trigger alarms anymore. Died!

- `Xiaomi Mi A1` has stopped triggering alarms on **2020-04-23 00:52:00** when running the basic scheduler. An explanation may be that Huawei/Honor smartphones on Android 9+ have a Launch Records where the OS records how much times an app has been launched by itself, so the OS has the possibility to detect this kind of apps. In these smartphones, Huawei also introduced a new task killer (Power Genius) which kills everything that is not whitelisted by Huawei, and does not give users any configuration options. Therefore, the Power Genius uses the information from the Launch Records to kill the scheduled alarms


### Which one of the analysed schedulers is more reliable? (Distribution of outliers)

In mental health intervetions, to have a predictable execution of planned actions is preferred since these notifications and/or alerts are delivered at the right moment. It is inconceivable, for example, that a patient gets a notification (action) 1 minute later than the event (she walks past a gambling  hall) that triggered it, because the patient could be dozens of meters away from the place of interest or, even worse, walked into that place. Therefore, closing the gap between the triggered event and the action is critical (time matters), especially because time and space/place must be in synchrony. If these tww diemsion are not in synchrony, the intervetion becomes less effective.

Given that average response time (delay) is similar in all devices (< 1second), outliers are a good candidate to study reliability. Fewer outliers would mean responses (delay) more predictable. Therefore, high values and/or frequent outliers would signal lack of synchrony between space/place and time dimensions in an intervention.

```{r outliers_table}
outliers <- 
  filter(data, outlier==1) %>%
  group_by(exp_id, scheduler, device_name) %>%
  summarise(n = n()) %>%
  arrange(device_name, scheduler, exp_id)

outliers_pos <- 
  filter(data, outlier_pos==1) %>%
  group_by(exp_id, scheduler, device_name) %>%
  summarise(n_pos = n()) %>%
  arrange(device_name, scheduler, exp_id)

outliers_neg <- 
  filter(data, outlier_neg==1) %>%
  group_by(exp_id, scheduler, device_name) %>%
  summarise(n_neg = n()) %>%
  arrange(device_name, scheduler, exp_id)

outliers <- 
  outliers %>% 
  left_join(outliers_pos, by = c("exp_id", "scheduler", "device_name")) %>%
  left_join(outliers_neg, by = c("exp_id", "scheduler", "device_name"))
  

kable(outliers %>%
        select(`Device` = device_name, 
               `# exp` = exp_id,
               `Type scheduler` = scheduler,
               `# outliers` = n, 
               `# outliers positive` = n_pos,
               `# outliers negative` = n_neg),
      format = "html",
      booktabs = TRUE,
      caption = "Table. Outliers per scheduler/device.") %>%
  kable_styling(full_width =FALSE,position = "left", bootstrap_options = c("striped", "bordered", "condensed")) %>%
  # collapse_rows(columns = 1, valign = "middle") %>%
  row_spec(c(8,10), color = "white", background = "#D7261E") %>%
  row_spec(3, color = "white", background = "orange")

```


```{r outliers_plot}
ggplot(outliers %>% filter(device_name %in% as.vector(devices))) +
  geom_bar(aes(x=device_name, y=n, fill=scheduler), stat = 'identity', position = position_dodge(preserve = 'single')) +
  theme_bw() +
  labs(title = "Absolute number of outliers per device")

```


**Observations**:

- Advanced scheduler beats the basic one in terms of number of outliers. `Honor 9` shows a remarkly difference. 

- Majority of outliers are positive (beyond top whisker).



```{r bubblechart_fundefs}

bubblechart_all_outliers <- function(sel_outliers, sel_title) {
  sel_outliers %>%
    ggplot(aes(x=date, y=plan_hour, color=factor(scheduler))) +
    geom_point(aes(size=n), alpha=0.2, na.rm = TRUE) +
    geom_text(aes(label=n), color="black", size=2, na.rm = TRUE) +
    scale_size_area(max_size=15) +
    scale_y_continuous(breaks = seq(0,23)) +
    scale_x_date(breaks = scales::date_breaks("1 day"),
                 labels = scales::date_format("%d-%m", tz="CET")) +
    theme_minimal() +
    labs(title = sel_title)
  
} 

```


#### BQ Aquaris V


```{r outliers_BQ}

sel_device <- names(devices)[1]
n_outliers_BQ <- nrow(filter(data, outlier==1, device_id ==sel_device))
n_outliers_pos_BQ <- nrow(filter(data, outlier_pos==1, device_id ==sel_device))
n_outliers_neg_BQ <- nrow(filter(data, outlier_neg==1, device_id ==sel_device))

outliers_BQ <- 
  filter(data, outlier==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))
outliers_pos_BQ <- 
  filter(data, outlier_pos==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))

outliers_neg_BQ <- 
  filter(data, outlier_neg==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))

```

- Number of outliers: `r n_outliers_BQ`

- Number of outliers (top range): `r n_outliers_pos_BQ` - `r round((n_outliers_pos_BQ / n_outliers_BQ)*100, 1)`% (`r scales::comma(n_outliers_pos_BQ, big.mark = ".")`/`r scales::comma(n_outliers_BQ, big.mark = ".")`).

- Number of outliers (bottom range): `r n_outliers_neg_BQ` - `r round((n_outliers_neg_BQ / n_outliers_BQ)*100, 1)`% (`r scales::comma(n_outliers_neg_BQ, big.mark = ".")`/`r scales::comma(n_outliers_BQ, big.mark = ".")`).


```{r outliers_BQ_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of outliers (ALL) grouped by hour (N=", n_outliers_BQ, ")")
outliers_BQ_bubblechart <- bubblechart_all_outliers(outliers_BQ, title)

outliers_BQ_bubblechart
```


```{r  outliers_pos_BQ_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of outliers (POS) grouped by hour (N=", n_outliers_pos_BQ, ")")
outliers_pos_BQ_bubblechart <- bubblechart_all_outliers(outliers_pos_BQ, title)

outliers_pos_BQ_bubblechart


```

```{r  outliers_neg_BQ_plot, fig.height=8, fig.width=18}

title <- paste0(sel_device, " - Count of outliers (NEG) grouped by hour (N=", n_outliers_neg_BQ, ")")
outliers_neg_BQ_bubblechart <- bubblechart_all_outliers(outliers_neg_BQ, title)
 
outliers_neg_BQ_bubblechart

```




#### Nvidia Shield Tablet

```{r outliers_NV}
sel_device <- names(devices)[2]
n_outliers_NV <- nrow(filter(data, outlier==1, device_id ==sel_device))
n_outliers_pos_NV <- nrow(filter(data, outlier_pos==1, device_id ==sel_device))
n_outliers_neg_NV <- nrow(filter(data, outlier_neg==1, device_id ==sel_device))

outliers_NV <- 
  filter(data, outlier==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))
outliers_pos_NV <- 
  filter(data, outlier_pos==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))

outliers_neg_NV <- 
  filter(data, outlier_neg==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))


```


- Number of outliers: `r n_outliers_NV`

- Number of outliers (top range): `r n_outliers_pos_NV` - `r round((n_outliers_pos_NV / n_outliers_NV)*100, 1)`% (`r scales::comma(n_outliers_pos_NV, big.mark = ".")`/`r scales::comma(n_outliers_NV, big.mark = ".")`).

- Number of outliers (bottom range): `r n_outliers_neg_NV` - `r round((n_outliers_neg_NV / n_outliers_NV)*100, 1)`% (`r scales::comma(n_outliers_neg_NV, big.mark = ".")`/`r scales::comma(n_outliers_NV, big.mark = ".")`).


```{r outliers_NV_plot, fig.height=8, fig.width=18}

title <- paste0(sel_device, " - Count of (ALL) outliers grouped by hour (N=", n_outliers_NV, ")")
outliers_NV_bubblechart <- bubblechart_all_outliers(outliers_NV, title)
outliers_NV_bubblechart
```

```{r  outliers_pos_NV_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of (POS) outliers grouped by hour (N=", n_outliers_pos_NV, ")")
outliers_pos_NV_bubblechart <- bubblechart_all_outliers(outliers_pos_NV, title)
outliers_pos_NV_bubblechart

```


```{r  outliers_neg_NV_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of (NEG) outliers grouped by hour (N=", n_outliers_neg_NV, ")")
outliers_neg_NV_bubblechart <- bubblechart_all_outliers(outliers_neg_NV, title)
outliers_neg_NV_bubblechart

```




#### Xiaomi Mi A1

```{r outliers_A1}
sel_device <- names(devices)[3]
n_outliers_A1 <- nrow(filter(data, outlier==1, device_id ==sel_device))
n_outliers_pos_A1 <- nrow(filter(data, outlier_pos==1, device_id ==sel_device))
n_outliers_neg_A1 <- nrow(filter(data, outlier_neg==1, device_id ==sel_device))

outliers_A1 <- 
  filter(data, outlier==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))
outliers_pos_A1 <- 
  filter(data, outlier_pos==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))

outliers_neg_A1 <- 
  filter(data, outlier_neg==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))


```


- Number of outliers: `r n_outliers_A1`

- Number of outliers (top range): `r n_outliers_pos_A1` - `r round((n_outliers_pos_A1 / n_outliers_A1)*100, 1)`% (`r scales::comma(n_outliers_pos_A1, big.mark = ".")`/`r scales::comma(n_outliers_A1, big.mark = ".")`).

- Number of outliers (bottom range): `r n_outliers_neg_A1` - `r round((n_outliers_neg_A1 / n_outliers_A1)*100, 1)`% (`r scales::comma(n_outliers_neg_A1, big.mark = ".")`/`r scales::comma(n_outliers_A1, big.mark = ".")`).


```{r outliers_A1_plot, fig.height=8, fig.width=18}

title <- paste0(sel_device, " - Count of (ALL) outliers grouped by hour (N=", n_outliers_A1, ")")
outliers_A1_bubblechart <- bubblechart_all_outliers(outliers_A1, title)
outliers_A1_bubblechart
```

```{r  outliers_pos_A1_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of (POS) outliers grouped by hour (N=", n_outliers_pos_A1, ")")
outliers_pos_A1_bubblechart <- bubblechart_all_outliers(outliers_pos_A1, title)
outliers_pos_A1_bubblechart

```


```{r  outliers_neg_A1_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of (NEG) outliers grouped by hour (N=", n_outliers_neg_A1, ")")
outliers_neg_A1_bubblechart <- bubblechart_all_outliers(outliers_neg_A1, title)
outliers_neg_A1_bubblechart

```


#### Honor 9


```{r outliers_H9}
sel_device <- names(devices)[4]
n_outliers_H9 <- nrow(filter(data, outlier==1, device_id ==sel_device))
n_outliers_pos_H9 <- nrow(filter(data, outlier_pos==1, device_id ==sel_device))
n_outliers_neg_H9 <- nrow(filter(data, outlier_neg==1, device_id ==sel_device))

outliers_H9 <- 
  filter(data, outlier==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))
outliers_pos_H9 <- 
  filter(data, outlier_pos==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))

outliers_neg_H9 <- 
  filter(data, outlier_neg==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))

```

- Number of outliers: `r n_outliers_H9`

- Number of outliers (top range): `r n_outliers_pos_H9` - `r round((n_outliers_pos_H9 / n_outliers_H9)*100, 1)`% (`r scales::comma(n_outliers_pos_H9, big.mark = ".")`/`r scales::comma(n_outliers_H9, big.mark = ".")`).

- Number of outliers (bottom range): `r n_outliers_neg_H9` - `r round((n_outliers_neg_H9 / n_outliers_H9)*100, 1)`% (`r scales::comma(n_outliers_neg_H9, big.mark = ".")`/`r scales::comma(n_outliers_H9, big.mark = ".")`).


```{r outliers_H9_plot, fig.height=8, fig.width=18}

title <- paste0(sel_device, " - Count of (ALL) outliers grouped by hour (N=", n_outliers_H9, ")")
outliers_H9_bubblechart <- bubblechart_all_outliers(outliers_H9, title)
outliers_H9_bubblechart
```


```{r  outliers_pos_H9_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of (POS) outliers grouped by hour (N=", n_outliers_pos_H9, ")")
outliers_pos_H9_bubblechart <- bubblechart_all_outliers(outliers_pos_H9, title)
outliers_pos_H9_bubblechart


```



```{r  outliers_neg_H9_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of (NEG) outliers grouped by hour (N=", n_outliers_neg_H9, ")")
outliers_neg_H9_bubblechart <- bubblechart_all_outliers(outliers_neg_H9, title)
outliers_neg_H9_bubblechart

```




#### Motorola Moto G


```{r outliers_MO}
sel_device <- names(devices)[5]
n_outliers_MO <- nrow(filter(data, outlier==1, device_id ==sel_device))
n_outliers_pos_MO <- nrow(filter(data, outlier_pos==1, device_id ==sel_device))
n_outliers_neg_MO <- nrow(filter(data, outlier_neg==1, device_id ==sel_device))

outliers_MO <- 
  filter(data, outlier==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))
outliers_pos_MO <- 
  filter(data, outlier_pos==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))

outliers_neg_MO <- 
  filter(data, outlier_neg==1, device_id ==sel_device) %>%
  group_by(scheduler, plan_month, plan_day, plan_hour) %>%
  summarise(n = n()) %>%
  mutate(date = lubridate::ymd(paste0("2020-",
                                        str_pad(plan_month, width=2, side="left", pad="0"),"-", 
                                        plan_day)))

```

- Number of outliers: `r n_outliers_MO`

- Number of outliers (top range): `r n_outliers_pos_MO` - `r round((n_outliers_pos_MO / n_outliers_MO)*100, 1)`% (`r scales::comma(n_outliers_pos_MO, big.mark = ".")`/`r scales::comma(n_outliers_MO, big.mark = ".")`).

- Number of outliers (bottom range): `r n_outliers_neg_MO` - `r round((n_outliers_neg_MO / n_outliers_MO)*100, 1)`% (`r scales::comma(n_outliers_neg_MO, big.mark = ".")`/`r scales::comma(n_outliers_MO, big.mark = ".")`).


```{r outliers_MO_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of (ALL) outliers grouped by hour (N=", n_outliers_MO, ")")
outliers_MO_bubblechart <- bubblechart_all_outliers(outliers_MO, title)
outliers_MO_bubblechart
```


```{r  outliers_pos_MO_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of (POS) outliers grouped by hour (N=", n_outliers_pos_MO, ")")
outliers_pos_MO_bubblechart <- bubblechart_all_outliers(outliers_pos_MO, title)
outliers_pos_MO_bubblechart

```



```{r  outliers_neg_MO_plot, fig.height=8, fig.width=18}
title <- paste0(sel_device, " - Count of (NEG) outliers grouped by hour (N=", n_outliers_neg_MO, ")")
outliers_neg_MO_bubblechart <- bubblechart_all_outliers(outliers_neg_MO, title)
outliers_neg_MO_bubblechart

```



### Which one of the analysed schedulers is more accurate? (Distribution of `delay`)


```{r dual_scale_plots_function}
source(here::here("R", "dual_scale_plot.R"))
```

Basic assumption: Higher accuracy = lower `delay`  

To evaluate it, we plot timestamps as follows (being "n" each row in the data file): 

- execution timestamp(n) -planning timestamp(n+1) [the current one, which displays framework overhead]
- planning timestamp(n-1) - planning timestamp(n) [in order to detect wrong planning timestamp values] 
- execution timestamp(n-1) - execution timestamp(n) [this last one should be reliable]


#### Analsysis of consecutive planning timestamps 

We calculate `planning timestamp(n-1) - planning timestamp(n)` to detect wrong planning timestamp values. 

```{r plan_dates_diff}
# sel_device_name <- devices[[1]]
diff_times <- 
  data %>%
  select(step, scheduler, device_id, device_name, delay, plan_date, exec_date) %>%
  arrange(step) # TODO: step

diff_times <- 
  diff_times %>%
  group_by(scheduler, device_id) %>%
  mutate(plan_date_lagged = lag(plan_date),
         plan_date_diff = as.numeric(as.duration(interval(plan_date_lagged, plan_date)) / dseconds(1)),
         plan_date_diff = ifelse(is.na(plan_date_diff), 0, round(plan_date_diff, 3)),
         plan_date_diff_cum = cumsum(plan_date_diff/60)) # units: minutes
         
         
diff_times <- 
  diff_times %>%
  group_by(scheduler, device_id) %>%
  arrange(exec_date) %>% # TODO: step
  mutate(exec_date_lagged = dplyr::lag(exec_date),
         exec_date_diff = as.numeric(as.duration(interval(exec_date_lagged, exec_date)) / dseconds(1)),
         exec_date_diff = round(exec_date_diff, 3))

```


```{r plan_dates_diff_summary}

# https://towardsdatascience.com/understanding-boxplots-5e2df7bcbd51
# Understanding Boxplot. What is a outlier?
# Min., 1st Qu., Median, Mean, 3rd Qu., Max.

col_names <- c("scheduler", "device_name", "min", "quartile1", "median", "quartile3", "max", "mean", "bottom_whisker", "top_whisker")
summaries_diff <- data.frame(matrix(ncol=length(col_names), nrow = 0))
colnames(summaries_diff) <- col_names

for (s in 1:length(schedulers)) {
  for (d in 1:length(devices)) {
    
    diff_times %>%
      filter(scheduler == schedulers[[s]]) %>%
      filter(device_name == devices[[d]]) %>%
      select(device_id, device_name, plan_date_diff) -> one
    
    summary_row <- data.frame(matrix(ncol=length(col_names), nrow = 0))
    colnames(summary_row) <- col_names
    
    mean <- mean(one$plan_date_diff, na.rm = TRUE)
    summary_boxplot <- boxplot(one$plan_date_diff, plot = FALSE) 
    bottom_whisker <- summary_boxplot$stats[1,1]
    top_whisker <-  summary_boxplot$stats[5,1]
    
    summary_row[1,] <- c(schedulers[[s]], devices[[d]], fivenum(one$plan_date_diff), mean, bottom_whisker, top_whisker)

    summaries_diff <- rbind(summaries_diff, summary_row)
  }
}

summaries_diff <- 
  summaries_diff %>%
  mutate_at(vars(c("scheduler", "device_name")), ~as.character(.)) %>% 
  mutate_at(vars(-c("scheduler", "device_name")), ~as.numeric(.)) %>%
  mutate_if(is.numeric, ~round(., 3))

# glimpse(summaries_diff)

data %>%
  group_by(exp_id, scheduler, device_name) %>%
  summarise(n = n(),
            start_datetime = min(plan_date),
            end_datetime = max(plan_date)) %>%
  inner_join(summaries_diff, by=c("scheduler", "device_name")) %>%
  arrange(exp_id, scheduler, device_name) -> summaries_diff_table

kable(summaries_diff_table %>%
        select(`# exp` = exp_id,
               `Type scheduler` = scheduler,
               `Device` = device_name,
               `# records` = n,
               `Start` = start_datetime,
               `End` = end_datetime,
               `Min` = min,
               `Bottom whisker`= bottom_whisker,
               `1st Qu.` = quartile1,
               `Median` = median,
               `Mean` = mean,
               `3rd Qu.` = quartile3,
               `Top whisker`= top_whisker,
               `Max` = max),
      format = "html",
      booktabs = TRUE,
      caption = "Table. Descriptive statistics of 'planning timestamp(n-1) - planning timestamp(n)' [in order to detect wrong planning timestamp values] per scheduler/device.") %>%
  kable_styling(full_width = TRUE, bootstrap_options = c("striped", "bordered", "condensed")) %>%
  collapse_rows(columns = 1:2, valign = "top")
  # row_spec(6, color = "white", background = "orange") %>%
  # row_spec(9:10, color = "white", background = "#D7261E")

```




```{r plan_date_diff_outliers}
diff_times <-
  diff_times %>%
  left_join(summaries_diff, by=c("scheduler", "device_name")) %>%
  mutate(plan_date_diff_outlier_pos = ifelse(plan_date_diff > top_whisker, 1, 0)) %>%
  mutate(plan_date_diff_outlier_neg = ifelse(plan_date_diff < bottom_whisker, 1, 0)) %>%
  mutate(plan_date_diff_outlier = ifelse((plan_date_diff_outlier_pos == 1 | plan_date_diff_outlier_neg == 1), 1, 0)) %>%
  arrange(device_name, step)
```

```{r plan_date_diff_outliers_table}
plan_date_outliers <- 
  filter(diff_times, plan_date_diff_outlier==1) %>%
  group_by(scheduler, device_name) %>%
  summarise(n = n()) %>%
  arrange(device_name, scheduler)

plan_date_outliers_pos <- 
  filter(diff_times, plan_date_diff_outlier_pos==1) %>%
  group_by(scheduler, device_name) %>%
  summarise(n_pos = n()) %>%
  arrange(device_name, scheduler)

plan_date_outliers_neg <- 
  filter(diff_times, plan_date_diff_outlier_neg==1) %>%
  group_by(scheduler, device_name) %>%
  summarise(n_neg = n()) %>%
  arrange(device_name, scheduler)

plan_date_outliers <- 
  plan_date_outliers %>% 
  left_join(plan_date_outliers_pos, by = c("scheduler", "device_name")) %>%
  left_join(plan_date_outliers_neg, by = c("scheduler", "device_name"))
  

kable(plan_date_outliers %>%
        select(`Device` = device_name, 
               `Type scheduler` = scheduler,
               `# outliers` = n, 
               `# outliers positive` = n_pos,
               `# outliers negative` = n_neg),
      format = "html",
      booktabs = TRUE,
      caption = "Table. Outliers of consecutive planning timestamps per scheduler/device.") %>%
  kable_styling(full_width =FALSE,position = "left", bootstrap_options = c("striped", "bordered", "condensed"))
  # row_spec(c(8,10), color = "white", background = "#D7261E") %>%
  # row_spec(3, color = "white", background = "orange")

```




```{r plan_date_diff_outliers_plot, fig.height=16, fig.width=16}

diff_times %>%
  filter(plan_date_diff_outlier ==1, plan_date_diff < 200) %>%  #TODO: What do I do with super outliers?
  ggplot(aes(x = step, color=factor(device_name))) +
    # geom_point(aes(y = delay), alpha = 0.6, size = 0.5) +
    geom_point(aes(y = plan_date_diff), alpha = 0.3, size = 0.7) +
    # geom_point(aes(y = exec_date_diff)) +
  
    labs(title="plan_date[n-1] - plan_date[n]",
         x = "Steps [~1min]") + 
    scale_y_continuous(name="diff [seconds]") + #, breaks=ybks_delay, limits=ylim_delay) +
    facet_grid(device_name~scheduler) +
    theme(legend.title = element_text(size=8), 
          legend.position="bottom",
          legend.direction = "horizontal") +
    theme_bw()

```




```{r plan_date_diff_cumsum_plot, fig.height=16, fig.width=16}

diff_times %>%
  # filter(plan_date_diff_outlier ==1)  %>%  #TODO: What do I do with super outliers?
  ggplot(aes(x = step, color=factor(device_name))) +
    # geom_point(aes(y = delay), alpha = 0.6, size = 0.5) +
    geom_line(aes(y = plan_date_diff_cum), alpha = 1, size = 0.5) +
    # geom_point(aes(y = exec_date_diff)) +
  
    labs(title="plan_date[n-1] - plan_date[n]",
         x = "Steps [~1min]") + 
    scale_y_continuous(name="diff [seconds]") + #, breaks=ybks_delay, limits=ylim_delay) +
    facet_grid(device_name~scheduler) +
    theme(legend.title = element_text(size=8), 
          legend.position="bottom",
          legend.direction = "horizontal") +
    theme_bw()

```


#### Execution timestamps

- execution timestamp(n-1) - execution timestamp(n) [this last one should be reliable]

```{r}


col_names <- c("scheduler", "device_name", "min", "quartile1", "median", "quartile3", "max", "mean", "bottom_whisker", "top_whisker")
summaries_diff <- data.frame(matrix(ncol=length(col_names), nrow = 0))
colnames(summaries_diff) <- col_names

for (s in 1:length(schedulers)) {
  for (d in 1:length(devices)) {
    
    diff_times %>%
      filter(scheduler == schedulers[[s]]) %>%
      filter(device_name == devices[[d]]) %>%
      select(device_id, device_name, exec_date_diff) -> one
    
    summary_row <- data.frame(matrix(ncol=length(col_names), nrow = 0))
    colnames(summary_row) <- col_names
    
    mean <- mean(one$exec_date_diff, na.rm = TRUE)
    summary_boxplot <- boxplot(one$exec_date_diff, plot = FALSE) 
    bottom_whisker <- summary_boxplot$stats[1,1]
    top_whisker <-  summary_boxplot$stats[5,1]
    
    summary_row[1,] <- c(schedulers[[s]], devices[[d]], fivenum(one$exec_date_diff), mean, bottom_whisker, top_whisker)

    summaries_diff <- rbind(summaries_diff, summary_row)
  }
}

summaries_diff <- 
  summaries_diff %>%
  mutate_at(vars(c("scheduler", "device_name")), ~as.character(.)) %>% 
  mutate_at(vars(-c("scheduler", "device_name")), ~as.numeric(.)) %>%
  mutate_if(is.numeric, ~round(., 3))

# glimpse(summaries_diff)

data %>%
  group_by(exp_id, scheduler, device_name) %>%
  summarise(n = n(),
            start_datetime = min(plan_date),
            end_datetime = max(plan_date)) %>%
  inner_join(summaries_diff, by=c("scheduler", "device_name")) %>%
  arrange(exp_id, scheduler, device_name) -> summaries_diff_table

kable(summaries_diff_table %>%
        select(`# exp` = exp_id,
               `Type scheduler` = scheduler,
               `Device` = device_name,
               `# records` = n,
               `Start` = start_datetime,
               `End` = end_datetime,
               `Min` = min,
               `Bottom whisker`= bottom_whisker,
               `1st Qu.` = quartile1,
               `Median` = median,
               `Mean` = mean,
               `3rd Qu.` = quartile3,
               `Top whisker`= top_whisker,
               `Max` = max),
      format = "html",
      booktabs = TRUE,
      caption = "Table. Descriptive statistics of 'execution timestamp(n-1) - execution timestamp(n)' per scheduler/device.") %>%
  kable_styling(full_width = TRUE, bootstrap_options = c("striped", "bordered", "condensed")) %>%
  collapse_rows(columns = 1:2, valign = "top")
  # row_spec(6, color = "white", background = "orange") %>%
  # row_spec(9:10, color = "white", background = "#D7261E")

```


```{r fig.height=8, fig.width=12}

diff_times %>%
  filter(exec_date_diff < 200) %>%
  ggplot(aes(x = step, color=factor(device_name))) +
    # geom_point(aes(y = delay), alpha = 0.6, size = 0.5) +
    geom_point(aes(y = exec_date_diff), alpha = 0.3, size = 0.7) +

    labs(title="exec_date[n-1] - exec_date[n]",
         x = "Steps [~1min]") + 
    # scale_x_datetime(breaks = scales::date_breaks("12 hours"),
    #                  labels = scales::date_format("%d-%m %H:%M", tz="CET"),
    #                  expand = c(0,0)) +
    scale_y_continuous(name="diff [seconds]") + #, breaks=ybks_delay, limits=ylim_delay) +
    
    # guides(color=guide_legend(title="Scheduler",
    #                           # override.aes=list(fill=NA),
    #                           nrow=2)) + 
    # 
    # guides(color=FALSE) +
    facet_grid(device_name~scheduler) +
    theme(legend.title = element_text(size=8), 
          legend.position="bottom",
          legend.direction = "horizontal") +
    theme_bw()

```


#### Framework overhead

- execution timestamp(n) - planning timestamp(n+1)


#### Delay

- (planning timestamp(n) - execution timestamp(n)) - 60


**BQ Aquaris V**

_How does `delay` behave in the middle 50% of data (IRQ)?_

Advance scheduler shows worse delay times. In addition, the central cluster shows steadily increased values of `delay` over time. In contrast, the basic scheduler shows uniform delays over time adn concentrated aoru 0.3 sec. Teh basic scheduler's boxplot shows a thinner box than the advance scheduler's. There seems no clear relationship between battery levels and delays, which suggests that low battery levels do not impact (or at least not significally) on the planned execution time of a task. 

```{r dual_scale_plots_BQ, fig.width=14, fig.height=10}
sel_device_name <- devices[[1]]
selection <- 
  data %>%
  filter(device_name == sel_device_name, outlier == 0) %>%
  arrange(plan_date)


plot_BQ_wo_outliers <- dual_scale_plot(selection, 
                           paste(sel_device_name, "(without outliers)"))

boxplot_BQ_wo_outliers <-
  filter(selection) %>%
    ggplot(aes(x = device_id, y = delay, fill=factor(exp_id))) + 
    geom_boxplot(alpha = 0.7) +
    facet_grid(~scheduler) +
    theme_bw() +
    # scale_fill_hue() +
    guides(fill=FALSE)

selection <- 
  data %>%
  filter(device_name == sel_device_name, outlier == 0, whisker == 0) %>%
  arrange(plan_date)


plot_BQ_wo_whisker <- dual_scale_plot(selection, 
                           paste(sel_device_name, "(without outliers & whiskers)"))

boxplot_BQ_wo_whisker <-
  filter(selection) %>%
    ggplot(aes(x = device_id, y = delay, fill=factor(exp_id))) + 
    geom_boxplot(alpha = 0.7,
                 outlier.colour = "#1F3552", outlier.shape = 20) +
    facet_grid(~scheduler) +
    theme_bw() +
    # scale_fill_hue() +
    guides(fill=FALSE)


ggarrange(plot_BQ_wo_outliers, boxplot_BQ_wo_outliers, 
          plot_BQ_wo_whisker, boxplot_BQ_wo_whisker, 
          widths = c(3, 1), heights = c(3, 3))

```


_What happens when battery is going to be fully recharged?_




**Honor 9**

_How does `delay` behave in the middle 50% of data (IRQ)?_


```{r dual_scale_plots_HO, fig.width=14, fig.height=8}

sel_device_name <- devices[[4]]
selection <- 
  data %>%
  filter(device_name == sel_device_name, outlier == 0) %>%
  arrange(plan_date)

plot_HO_wo_outliers <- dual_scale_plot(selection, 
                           paste(sel_device_name, "(without outliers)"))

selection <- 
  data %>%
  filter(device_name == sel_device_name, outlier == 0, whisker == 0) %>%
  arrange(plan_date)


plot_HO_wo_whisker <- dual_scale_plot(selection, 
                           paste(sel_device_name, "(without outliers & whiskers)"))


plot_HO_wo_outliers

plot_HO_wo_whisker
```

**Motorola Moto G**

```{r dual_scale_plots_MO, fig.width=14, fig.height=8}
sel_device_name <- devices[[5]]
selection <- 
  data %>%
  filter(device_name == sel_device_name, outlier == 0) %>%
  arrange(plan_date)

plot_MO_wo_outliers <- dual_scale_plot(selection, 
                           paste(sel_device_name, "(without outliers)"))

selection <- 
  data %>%
  filter(device_name == sel_device_name, outlier == 0, whisker == 0) %>%
  arrange(plan_date)


plot_MO_wo_whisker <- dual_scale_plot(selection, 
                           paste(sel_device_name, "(without outliers & whiskers)"))


plot_MO_wo_outliers

plot_MO_wo_whisker
```


See the [shiny app](https://cgranell.shinyapps.io/symptoms-scheduler/)! (TO BE UPDATED)



### Does the battery level influence timely alarm execution? (Distribution of `delay` over `battery` - without outliers)

```{r battery_delay_data, eval=TRUE}

scheduler_levels = c("Advanced", "Basic")
devices_levels = as.vector(devices)

battery_delay_data <-
  filter(data, outlier == 0) %>%
  select(exp_id, scheduler, device_id, device_name, battery, delay) %>%
  mutate(scheduler = factor(scheduler, levels = scheduler_levels),
         device_name = factor(device_name, levels=devices_levels))
```

```{r plot_battery_delay, fig.height=10, fig.width=12, warning=FALSE}

p_battery_delay <-
  battery_delay_data %>%
  ggplot(aes(x = battery, y = delay)) + 
  geom_point(aes(color=device_name), alpha = 0.5, size = 0.4) +
  facet_grid(device_name ~ scheduler) +
  theme_bw() +
  guides(colour=FALSE)

p_battery_delay 

```


### Which one of the analysed schedulers loses fewer alarm executions? 

Higher reliability = higher percentage of alarms executed / expected alarms for the experiment time frame


### Boxplots


Distribution of data based on a five number summary (“minimum”, first quartile (Q1), median, third quartile (Q3), and “maximum”).

Basic statistics applied to `delay` and `device_name`. Given a device, _how do the box plots change on each `scheduler`?_
```{r boxplot_data}
bp_data_all <- 
  data %>%
  # filter(data, outlier == "no") %>%
  mutate(exp_id = factor(exp_id)) %>%
  select(exp_id, scheduler, device_id, device_name, plan_date, delay)
```

```{r boxplot_paired, fig.height=6, fig.width=8, eval=FALSE}

filter(bp_data_all, exp_id=="#1") %>%
  ggplot(aes(x = device_id, y = delay, fill=device_id)) + #, fill=factor(exp_id))) +
  geom_boxplot(alpha = 0.7,
               outlier.colour = "#1F3552", outlier.shape = 20) +
  # facet_grid(~device_name) +
  theme_bw() +
  # scale_fill_hue() +
  guides(fill=FALSE)

boxplot(bp_data_all$delay ~ bp_data_all$device_id)

```





```{r boxplot_all_faceted, fig.height=6, fig.width=8, eval=FALSE}

bp_data_all_p  <- 
  bp_data_all %>%
  ggplot(aes(x = plan_date, y = delay, fill=exp_id)) + #, fill=factor(exp_id))) +
  geom_boxplot(alpha = 0.7,
               outlier.colour = "#1F3552", outlier.shape = 20) +
  facet_grid(device_name ~ scheduler) +
  theme_bw() +
  scale_fill_hue()
  # guides(fill=FALSE)

bp_data_all_p


```


```{r}

# ggplotly(bp_data_all_p)
```
 

```{r boxplot_all_faceted_plotly, warning=FALSE, eval=FALSE}
p <- 
  bp_data_all %>%
  plot_ly(y = ~delay, x = ~interaction(scheduler, device_name), 
          alpha = 0.1, 
          boxpoints = "suspectedoutliers") %>%
  add_boxplot(color = ~device_name) %>%
  layout(xaxis = list(title = " "))

p  
```




```{r boxplot_scheduler_plotly, eval=FALSE}

p <-
  bp_data_all %>%
  plot_ly(y = ~delay,
          alpha = 0.1,
          boxpoints = "suspectedoutliers")

p1 <- p %>% add_boxplot(x = "Overall", name="Overall")
p2 <- p %>% add_boxplot(x = ~device_name, color=~scheduler)

subplot(
  p1, p2, shareY = TRUE,
  widths = c(0.2, 0.8), margin = 0
) #%>% hide_legend()


```



