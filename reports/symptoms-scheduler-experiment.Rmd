---
title: "Symptoms - scheduler experiment"
author: "Carlos Granell, [SyMptOMS team](http://geotec.uji.es/projects/SyMptOMS/), [GEOTEC research group](http://geotec.uji.es/) "
date: "17/4/2020 (updated `r format(Sys.time(), '%d %B, %Y')`)"
output: 
  html_document:
    df_print: paged
    toc: yes
---

```{r setup, include=FALSE, eval=TRUE}
knitr::opts_chunk$set(echo = FALSE)
```

This document analyses the self-developed scheduler component in Android-based mobile devices as part of the [SyMptOMS project](http://geotec.uji.es/projects/SyMptOMS/). 


## Reproduce notebook

To create the PDF of the computational notebook you can run the following commands in a new R session.
If you have problems rendering the PDF you can execute each chunk independently in [RStudio](https://rstudio.com/products/rstudio/).

```{r render_with_rmarkdown, eval=FALSE}
require("knitr")
require("rmarkdown")
rmarkdown::render("symptoms-scheduler-experiment.Rmd", output_format = "pdf_document")
```

This document does not install the required R packages by default.
You can run the script `install.R` to install all required dependencies on a new R installation, or use `install.packages(..)` to install missing R packages.

```{r install_r, eval=FALSE}
source("R/install.R")
```

The plots and tables use the packages [`ggplot2`](http://ggplot2.tidyverse.org/), [`knitr::kable()`](https://yihui.name/knitr/) and [`kableExtra`](https://cran.r-project.org/package=kableExtra).

Required libraries and runtime environment description are as follows.

```{r load_libraries, echo=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
library(kableExtra)
library(here)
library(googledrive)
library(lubridate)
library(stringr)
library(scales)
library(plotly)
library(grid)
library(gridBase)
library(gridExtra)
library(egg)
```


```{r set_seed}
# just in case
set.seed(nchar("Symptoms - scheduler experiment"))
```

## Data download

Log files are stored in shared gdrvie folder. This notebook downloads them locally in the folder`data-raw`.

```{r gsheetdata_files}

files <- tibble(
  experiment = c(rep("#1", 5), rep("#2", 5)),
  gsheets_name = c("AD_BQ.csv", "AD_NV.csv", "AD_A1.csv", "BA_H9.csv", "BA_MO.csv",
                   "BA_BQ.csv", "BA_NV.csv", "BA_A1.csv", "AD_H9.csv", "AD_MO.csv"),
  gsheets_link = c("https://drive.google.com/open?id=1fP9r0S8ORa689yHRtfCtYQothLuGcCw3",
                   "https://drive.google.com/open?id=1l-vnaT-Smy0SegArIz5A108-IQ2_jmVV",
                   "https://drive.google.com/open?id=1gzk1ezN5t5yBv2RnbznUqvalDx97eu3o",
                   "https://drive.google.com/open?id=1BLXO4Rvz6ppWFJe5oN9Y0hKh__ypofxk",
                   "https://drive.google.com/open?id=1RizGjKR8QLOdJna7qGPP7dYX9WWAysO4",
                   "https://drive.google.com/open?id=1rfaooLZ0Up0gNx1SCA92TV1JFxcLU0sk",
                   "https://drive.google.com/open?id=1_KIXX5FGXv7MO37QbUDnd_KGqiGihiMI",
                   "https://drive.google.com/open?id=1LezrtyB9i4K7cQsmI78E0v_KaOyhZcXI",
                   "https://drive.google.com/open?id=1ISjsfSLZt6n9miryQtDr-tsZV9bfbCDT",
                   "https://drive.google.com/open?id=1bx2RVNz05qVKGr-32GI-ZIOKQWlqKBPz")
)
```

```{r gsheetdata_files_table}
kable(files,
      format = "html",
      booktabs = TRUE,
      caption = "Table. List of raw data files.") %>%
  kable_styling(full_width = TRUE, bootstrap_options = c("striped", "bordered", "condensed"))

```


```{r gsheetdata_download, eval=FALSE}
for (f in 1:nrow(files)) {
  gfile_name <-files$gsheets_name[f]
  gfile_id <- googledrive::as_id(files$gsheets_link[f])
  
  drive_download(file = gfile_id, 
                 path = here::here("data-raw", gfile_name), 
                 overwrite = TRUE, verbose = FALSE)
}

```

```{r drive_disconnect, eval=FALSE}
drive_deauth()
```


## Data preparation

Raw data files are cleaned and merged together into a single file stored in the folder `data`. New fields such as dates breakdown are computed too. 

```{r merge_datafiles_defs}

schedulers <- c("AD" = "Advanced", 
                "BA" = "Basic")

devices <- c("BQ" = "BQ Aquaris V",
             "NV" = "Nvidia Shield Tablet",
             "A1" = "Xiaomi Mi A1",
             "H9" = "Honor 9",
             "MO" = "Motorola Moto G")

baseline_delay <- 60
```


```{r merge_datafiles, eval=FALSE}

data_path <- here::here("data-raw")
file_names <- list.files(path  = data_path)
file_paths <- list.files(path = data_path, full.names = TRUE)

data_merged <- data.frame()

get_experiment_id <- function(filename) {
  fullname <- paste0(filename, ".csv")
  files %>%
    filter(gsheets_name == fullname) %>%
    select(experiment) %>%
    pull
}

for (f in 1:length(file_names)) {
  filename <- stringr::str_sub(file_names[f], 1, 5)
  exp_id <- get_experiment_id(filename)
  
  parts <- stringr::str_split(filename, "_", simplify = TRUE)
  
  scheduler_id = parts[1]
  scheduler_name <- schedulers[[scheduler_id]]
  device_id <- parts[2]
  device_name <- devices[[device_id]]
  device_desc <- paste0(scheduler_name, " - ", device_name)
  
  data_temp <- read_csv(file_paths[f], col_names = TRUE, 
                        cols(
                          battery = col_double(),
                          exec_timestamp = col_double(),
                          planning_timestamp = col_double(),
                          task = col_character()
                        ))


  data_temp <- 
    data_temp %>%
    mutate(exp_id = exp_id,
           scheduler = scheduler_name,
           device_id = device_id,
           device_name = device_name,
           device_desc = device_desc) 
  
  data_merged <- rbind(data_merged, data_temp)
}       


data_merged <- 
  data_merged %>%
  mutate(exec_date = as_datetime(exec_timestamp/1000, tz="Europe/Madrid"),
         plan_date = as_datetime(planning_timestamp/1000, tz="Europe/Madrid"),
         plan_hour = lubridate::hour(plan_date),
         plan_day = lubridate::day(plan_date),
         plan_month = lubridate::month(plan_date),
         time_period = ifelse(between(plan_hour,0, 7), "nighttime", "daytime"))


# Delay time is in seconds
data_merged <-
  data_merged %>%
  group_by(device_id) %>%
  arrange(plan_date) %>%
  mutate(step = row_number(),
         delay = (as.duration(interval(plan_date, exec_date)) - baseline_delay) / dseconds(1))


# Outliers
# means <- 
#   data_merged %>%
#   group_by(device_id) %>%
#   summarise(mean = round(mean(delay), 3),
#             sd = round(sd(delay), 3),
#             lo = round(mean - 2*sd, 3),
#             hi = round(mean + 2*sd, 3))
# 
# data_complete <- 
#   left_join(data_merged, means, by="device_id") %>%
#   mutate(outlier = ifelse((delay < lo | delay > hi), "yes", "no")) %>%
#   arrange(device_id, plan_date)
  

data_path <- here::here("data", "data.csv")
write_csv(data_complete, data_path)
data_path <- here::here("data", "data.rds")
saveRDS(data_complete, data_path)

#TODO: 
# data_path <- here::here("webapp","data", "data.csv")
# write_csv(data_complete, data_path)
# data_path <- here::here("webapp","data", "data.rds")
# saveRDS(data_complete, data_path)

```

__Key Variables__:

- quantitative (interval)

  - `plan_date` (_datetime_): task planning time.
  - `exec_date` (_datetime_): task execution time.  
- quantitative (ratio)

  - `delay` (_numeric_): execution delay in seconds ((`exec_date` - `plan_date`) - `r baseline_delay`).
- categorital (ordinal)

  - `battery`(_numeric_): battery level
- categorical (nominal)

  - `device_id`/`device_name`: device identifier/name
  - `exp_id`: experiment identifier.
  - `scheduler`: scheduler type.
  

## Exploratory analysis


### Distribution of the data

```{r load_assessdata, warning=FALSE}
assessment_file <- here::here("data", "data.rds")
data <- readRDS(assessment_file)

n_observations <- nrow(data) 

```


```{r stats_summary_table}

# https://towardsdatascience.com/understanding-boxplots-5e2df7bcbd51
# Understanding Boxplot. What is a outlier?
# Min., 1st Qu., Median, Mean, 3rd Qu., Max.

col_names <- c("scheduler", "device_name", "min", "quartile1", "median", "quartile3", "max", "mean", "bottom_whisker", "top_whisker")
summaries <- data.frame(matrix(ncol=length(col_names), nrow = 0))
colnames(summaries) <- col_names

for (s in 1:length(schedulers)) {
  for (d in 1:length(devices)) {
    
    data %>%
      filter(scheduler == schedulers[[s]]) %>%
      filter(device_name == devices[[d]]) %>%
      select(device_id, device_name, delay) -> one
    
    summary_row <- data.frame(matrix(ncol=length(col_names), nrow = 0))
    colnames(summary_row) <- col_names
    
    mean <- mean(one$delay)
    summary_boxplot <- boxplot(one$delay, plot = FALSE) 
    bottom_whisker <- summary_boxplot$stats[1,1]
    top_whisker <-  summary_boxplot$stats[5,1]
    
    summary_row[1,] <- c(schedulers[[s]], devices[[d]], fivenum(one$delay), mean, bottom_whisker, top_whisker)

    summaries <- rbind(summaries, summary_row)
  }
}

summaries <- 
  summaries %>%
  mutate_at(vars(c("scheduler", "device_name")), ~as.character(.)) %>% 
  mutate_at(vars(-c("scheduler", "device_name")), ~as.numeric(.)) %>%
  mutate_if(is.numeric, ~round(., 3))

# glimpse(summaries)

data %>%
  group_by(exp_id, scheduler, device_name) %>%
  summarise(n = n(),
            start_datetime = min(plan_date),
            end_datetime = max(plan_date)) %>%
  inner_join(summaries, by=c("scheduler", "device_name")) %>%
  arrange(exp_id, scheduler, device_name) -> stats_summaries

kable(stats_summaries %>%
        select(`# exp` = exp_id,
               `Type scheduler` = scheduler,
               `Device` = device_name,
               `# records` = n,
               `Start` = start_datetime,
               `End` = end_datetime,
               `Min` = min,
               `Bottom whisker`= bottom_whisker,
               `1st Qu.` = quartile1,
               `Median` = median,
               `Mean` = mean,
               `3rd Qu.` = quartile3,
               `Top whisker`= top_whisker,
               `Max` = max),
      format = "html",
      booktabs = TRUE,
      caption = "Table. Descriptive statistics of data distribution and centrality per scheduler/device.") %>%
  kable_styling(full_width = TRUE, bootstrap_options = c("striped", "bordered", "condensed")) %>%
  collapse_rows(columns = 1:2, valign = "top") %>%
  row_spec(9:10, color = "white", background = "#D7261E")

```



```{r outliers}

devices_OK <- c("BQ" = "BQ Aquaris V",
                "H9" = "Honor 9",
                "MO" = "Motorola Moto G")

data %>% 
  left_join(summaries, by=c("scheduler", "device_name")) %>%
  mutate(outlier = ifelse((delay < bottom_whisker | delay > top_whisker), 1, 0)) %>%
  mutate(whisker = ifelse((delay > bottom_whisker & delay < quartile1) | (delay > quartile3 & delay < top_whisker), 1, 0)) %>%
  select(-min,-bottom_whisker, -quartile1, -mean, -median, -quartile3, -top_whisker, -max) %>%
  arrange(device_id, plan_date) -> data


n_outliers <- nrow(filter(data, outlier == 1))
n_whisker <- nrow(filter(data, whisker == 1))
n_irq <- nrow(filter(data, outlier == 0 & whisker == 0))

```

**Observations**:

- `r scales::comma(n_observations, big.mark = ".")` records in total. 

- `r round((n_irq / n_observations)*100, 1)`% (`r scales::comma(n_irq, big.mark = ".")`/`r scales::comma(n_observations, big.mark = ".")`) is the interquartile range or [IQR](https://en.wikipedia.org/wiki/Interquartile_range), i.e. the middle 50% of the data.

- `r round((n_whisker / n_observations)*100, 1)`% (`r scales::comma(n_whisker, big.mark = ".")`/`r scales::comma(n_observations, big.mark = ".")`) represent the _reasonable_ extremes of the data, i.e. these whisker values are the minimum and maximum values that do not exceed 1.5 × IQR.

- `r round((n_outliers / n_observations)*100, 1)`% (`r scales::comma(n_outliers, big.mark = ".")`/`r scales::comma(n_observations, big.mark = ".")`) are outliers, i.e. values beyond the top and bottom whiskers.

- `Nvidia Shield Tablet` has stopped triggering alarms on  **2020-04-17 22:27:06** when running the basic scheduler. Since there's no _watchdog_ in the basic version, this device is not going to trigger alarms anymore. Died!

- `Xiaomi Mi A1` has stopped triggering alarms on **2020-04-23 00:52:00** when running the basic scheduler. Died!

- It makes sense to continue the analysis with the 3 devices that completed the two experiments: `Honor 9`, `Motorola Moto G`, and 
`BQ Aquaris V`.

### Outliers

```{r outliers_table}
outliers <- 
  filter(data, outlier==1) %>%
  group_by(exp_id, scheduler, device_name) %>%
  summarise(n = n()) %>%
  arrange(device_name, scheduler, exp_id)

kable(outliers %>%
        select(`Device` = device_name, 
               `# exp` = exp_id,
               `Type scheduler` = scheduler,
               `# outliers` = n),
      format = "html",
      booktabs = TRUE,
      caption = "Table. Outliers per scheduler/device.") %>%
  kable_styling(full_width =FALSE,position = "left", bootstrap_options = c("striped", "bordered", "condensed")) %>%
  collapse_rows(columns = 1, valign = "middle") %>%
  row_spec(c(8,10), color = "white", background = "#D7261E")
```



```{r outliers_plot}
ggplot(outliers %>% filter(device_name %in% as.vector(devices_OK))) +
  geom_bar(aes(x=device_name, y=n, fill=scheduler), stat = 'identity', position = position_dodge(preserve = 'single')) +
  theme_bw() +
  labs(title = "Absolute number of outliers per device")

```


**Observations**:

- Avanced scheduler beats the basic one in terms of number of outliers. `Honor 9` shows a remarkly difference. 

  
### Distribution of `delay` over `plan_date`


```{r dual_scale_plots_function}
source(here::here("R", "dual_scale_plot.R"))
```

**BQ Aquaris V**: Advance scheduler show worse delay times. In addition, delays steadily increase over time. In contrast, the basic scheduler shows uniform delays over time adn concentrated aoru 0.3 sec. Teh basic scheduler's boxplot shows a thinner box than the advance scheduler's. There seems no clear relationship between battery levels and delays, which suggests that low battery levels do not impact (or at least not significally) on the planned execution time of a task. 

_To explore: what happens when battery is fully recharged?_

```{r dual_scale_plots_BQ, fig.width=14, fig.height=10}
selection <- 
  data %>%
  filter(device_name == devices_OK[[1]], outlier == 0) %>%
  arrange(plan_date)


plot_BQ_wo_outliers <- dual_scale_plot(selection, 
                           paste(devices_OK[[1]], "(without outliers)"))

boxplot_BQ_wo_outliers <-
  filter(selection) %>%
    ggplot(aes(x = device_id, y = delay, fill=factor(exp_id))) + 
    geom_boxplot(alpha = 0.7) +
    facet_grid(~scheduler) +
    theme_bw() +
    # scale_fill_hue() +
    guides(fill=FALSE)

selection <- 
  data %>%
  filter(device_name == devices_OK[[1]], outlier == 0, whisker == 0) %>%
  arrange(plan_date)


plot_BQ_wo_whisker <- dual_scale_plot(selection, 
                           paste(devices_OK[[1]], "(without outliers & whiskers)"))


boxplot_BQ_wo_whisker <-
  filter(selection) %>%
    ggplot(aes(x = device_id, y = delay, fill=factor(exp_id))) + 
    geom_boxplot(alpha = 0.7,
                 outlier.colour = "#1F3552", outlier.shape = 20) +
    facet_grid(~scheduler) +
    theme_bw() +
    # scale_fill_hue() +
    guides(fill=FALSE)



# plot_BQ_wo_outliers
# plot_BQ_wo_whisker
# 
# boxplot_BQ_wo_outliers
# boxplot_BQ_wo_whisker
# 
# 
# grid.arrange(plot_BQ_wo_outliers, boxplot_BQ_wo_outliers, nrow = 1)

ggarrange(plot_BQ_wo_outliers, boxplot_BQ_wo_outliers, 
          plot_BQ_wo_whisker, boxplot_BQ_wo_whisker, 
          widths = c(3, 1), heights = c(3, 3))

```


**Honor 9**:

```{r dual_scale_plots_HO, fig.width=14, fig.height=8}

selection <- 
  data %>%
  filter(device_name == devices_OK[[2]], outlier == 0) %>%
  arrange(plan_date)

plot_HO_wo_outliers <- dual_scale_plot(selection, 
                           paste(devices_OK[[2]], "(without outliers)"))

selection <- 
  data %>%
  filter(device_name == devices_OK[[2]], outlier == 0, whisker == 0) %>%
  arrange(plan_date)


plot_HO_wo_whisker <- dual_scale_plot(selection, 
                           paste(devices_OK[[2]], "(without outliers & whiskers)"))


plot_HO_wo_outliers

plot_HO_wo_whisker
```

**Motorola Moto G**:

```{r dual_scale_plots_MO, fig.width=14, fig.height=8}

selection <- 
  data %>%
  filter(device_name == devices_OK[[3]], outlier == 0) %>%
  arrange(plan_date)

plot_MO_wo_outliers <- dual_scale_plot(selection, 
                           paste(devices_OK[[3]], "(without outliers)"))

selection <- 
  data %>%
  filter(device_name == devices_OK[[3]], outlier == 0, whisker == 0) %>%
  arrange(plan_date)


plot_MO_wo_whisker <- dual_scale_plot(selection, 
                           paste(devices_OK[[3]], "(without outliers & whiskers)"))


plot_MO_wo_outliers

plot_MO_wo_whisker
```


See the [shiny app](https://cgranell.shinyapps.io/symptoms-scheduler/)! (TO BE UPDATED)


### Distribution of `delay` over `battery` (without outliers)

```{r battery_delay_data, eval=TRUE}

scheduler_levels = c("Advanced", "Basic")
devices_levels = as.vector(devices)

battery_delay_data <-
  filter(data, outlier == 0) %>%
  select(exp_id, scheduler, device_id, device_name, battery, delay) %>%
  mutate(scheduler = factor(scheduler, levels = scheduler_levels),
         device_name = factor(device_name, levels=devices_levels))
```

```{r plot_battery_delay, fig.height=10, fig.width=12, warning=FALSE}

p_battery_delay <-
  battery_delay_data %>%
  ggplot(aes(x = battery, y = delay)) + 
  geom_point(aes(color=device_name), alpha = 0.5, size = 0.4) +
  facet_grid(device_name ~ scheduler) +
  theme_bw() +
  guides(colour=FALSE)

p_battery_delay 

```



### Boxplots


Distribution of data based on a five number summary (“minimum”, first quartile (Q1), median, third quartile (Q3), and “maximum”).

Basic statistics applied to `delay` and `device_name`. Given a device, _how do the box plots change on each `scheduler`?_
```{r boxplot_data}
bp_data_all <- 
  data %>%
  # filter(data, outlier == "no") %>%
  mutate(exp_id = factor(exp_id)) %>%
  select(exp_id, scheduler, device_id, device_name, plan_date, delay)
```

```{r boxplot_paired, fig.height=6, fig.width=8, eval=FALSE}

filter(bp_data_all, exp_id=="#1") %>%
  ggplot(aes(x = device_id, y = delay, fill=device_id)) + #, fill=factor(exp_id))) +
  geom_boxplot(alpha = 0.7,
               outlier.colour = "#1F3552", outlier.shape = 20) +
  # facet_grid(~device_name) +
  theme_bw() +
  # scale_fill_hue() +
  guides(fill=FALSE)

boxplot(bp_data_all$delay ~ bp_data_all$device_id)

```





```{r boxplot_all_faceted, fig.height=6, fig.width=8, eval=FALSE}

bp_data_all_p  <- 
  bp_data_all %>%
  ggplot(aes(x = plan_date, y = delay, fill=exp_id)) + #, fill=factor(exp_id))) +
  geom_boxplot(alpha = 0.7,
               outlier.colour = "#1F3552", outlier.shape = 20) +
  facet_grid(device_name ~ scheduler) +
  theme_bw() +
  scale_fill_hue()
  # guides(fill=FALSE)

bp_data_all_p


```


```{r}

# ggplotly(bp_data_all_p)
```
 

```{r boxplot_all_faceted_plotly, warning=FALSE, eval=FALSE}
p <- 
  bp_data_all %>%
  plot_ly(y = ~delay, x = ~interaction(scheduler, device_name), 
          alpha = 0.1, 
          boxpoints = "suspectedoutliers") %>%
  add_boxplot(color = ~device_name) %>%
  layout(xaxis = list(title = " "))

p  
```




```{r boxplot_scheduler_plotly, eval=FALSE}

p <-
  bp_data_all %>%
  plot_ly(y = ~delay,
          alpha = 0.1,
          boxpoints = "suspectedoutliers")

p1 <- p %>% add_boxplot(x = "Overall", name="Overall")
p2 <- p %>% add_boxplot(x = ~device_name, color=~scheduler)

subplot(
  p1, p2, shareY = TRUE,
  widths = c(0.2, 0.8), margin = 0
) #%>% hide_legend()


```



